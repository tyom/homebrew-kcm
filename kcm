#!/usr/bin/env bash
# km: Keychain Master - Secret management utility for macOS Keychain
# Version: 0.1.0
#
# Usage:
#   km add KEY_NAME [value]     - Add secret to Keychain
#   km remove KEY_NAME          - Remove secret from Keychain
#   km show KEY_NAME            - Display secret value
#   km copy KEY_NAME            - Copy secret to clipboard (auto-clears after 45s)
#   km ls [pattern]             - List secrets matching pattern
#   km use [options] -- command - Run command with secrets from .env
#   km help                     - Show this help message
#
# Examples:
#   km add DATABASE_URL "postgresql://user:pass@host/db"
#   km add API_KEY              # Interactive mode
#   echo "secret" | km add TOKEN -  # From stdin
#   km remove OLD_KEY
#   km show DATABASE_URL
#   km copy API_KEY
#   km ls "DATABASE*"           # List all DATABASE secrets
#   km use --env-file .env -- npm run dev

set -e

VERSION="0.1.0"
SCRIPT_NAME="$(basename "$0")"
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
error_exit() {
  echo -e "${RED}Error: $1${NC}" >&2
  exit 1
}

success() {
  echo -e "${GREEN}✓${NC} $1" >&2
}

info() {
  echo -e "${YELLOW}ℹ${NC} $1" >&2
}

show_help() {
  cat << EOF
kcm - Keychain Master

USAGE:
  $SCRIPT_NAME <command> [options]

COMMANDS:
  add KEY_NAME [value]
    Add a secret to Keychain and output the .env entry

    Options:
      KEY_NAME "value"  - Add secret with specified value
      KEY_NAME          - Interactive mode (prompts for value)
      KEY_NAME -        - Read value from stdin

    Examples:
      kcm add DATABASE_URL "postgresql://user:pass@host/db"
      kcm add API_KEY      # Prompts for value
      echo "secret" | kcm add TOKEN -
      cat ~/secret.txt | kcm add AWS_KEY -

  remove KEY_NAME
    Remove a secret from Keychain

    Example:
      kcm remove OLD_API_KEY

  show KEY_NAME
    Display the value of a secret from Keychain

    Example:
      kcm show DATABASE_URL

  copy KEY_NAME
    Copy a secret value to clipboard (auto-clears after 45 seconds)

    Example:
      kcm copy API_KEY

  ls [pattern]
    List secrets in Keychain matching pattern (supports wildcards)

    Examples:
      kcm ls               # List all secrets
      kcm ls DATABASE*     # List secrets starting with DATABASE
      kcm ls *_KEY         # List secrets ending with _KEY

  use [options] -- command [args...]
    Run a command with secrets from .env file resolved

    Options:
      --env-file FILE   - Specify the .env file to use (default: .env)

    Examples:
      kcm use --env-file .env -- npm run dev
      kcm use --env-file ../.env -- make run-server
      kcm use --env-file .env -- echo \$DATABASE_URL

  help
    Show this help message

ENVIRONMENT VARIABLE FORMAT:
  keychain://LABEL - Retrieved from macOS Keychain

  If a secret cannot be resolved, the original value is used as fallback.

EOF
}

# Function to add secret to keychain
add_secret() {
  # Check if running on macOS
  if ! command -v security >/dev/null 2>&1; then
    error_exit "This command requires macOS with the 'security' command"
  fi

  if [ $# -lt 1 ]; then
    echo -e "${RED}Error: KEY_NAME is required${NC}" >&2
    echo "" >&2
    echo "Usage: $SCRIPT_NAME add KEY_NAME [value]" >&2
    echo "" >&2
    echo "Examples:" >&2
    echo "  $SCRIPT_NAME add DATABASE_URL \"postgresql://...\"" >&2
    echo "  $SCRIPT_NAME add API_KEY                    # Interactive" >&2
    echo "  echo \"secret\" | $SCRIPT_NAME add TOKEN -   # From stdin" >&2
    exit 1
  fi

  local KEY_NAME="$1"
  local SECRET_VALUE=""

  # Validate key name (alphanumeric and underscore only)
  if ! echo "$KEY_NAME" | grep -qE '^[A-Za-z][A-Za-z0-9_]*$'; then
    error_exit "Key name must start with a letter and contain only letters, numbers, and underscores"
  fi

  # Get the secret value
  if [ $# -eq 1 ]; then
    # Interactive mode - prompt for value
    info "Enter secret value for $KEY_NAME (input will be hidden):"
    read -rs SECRET_VALUE
    echo "" >&2  # New line after hidden input

    if [ -z "$SECRET_VALUE" ]; then
      error_exit "Secret value cannot be empty"
    fi
  elif [ "$2" = "-" ]; then
    # Read from stdin
    SECRET_VALUE=$(cat)

    if [ -z "$SECRET_VALUE" ]; then
      error_exit "No input received from stdin"
    fi
  else
    # Value provided as argument
    SECRET_VALUE="$2"
  fi

  # Check if entry already exists
  if security find-generic-password -s "$KEY_NAME" >/dev/null 2>&1; then
    info "Keychain entry '$KEY_NAME' already exists. Updating..."
    # Delete existing entry (suppress all output)
    security delete-generic-password -s "$KEY_NAME" >/dev/null 2>&1
  fi

  # Add to keychain (suppress verbose output)
  if security add-generic-password -s "$KEY_NAME" -a "$USER" -w "$SECRET_VALUE" -U >/dev/null 2>&1; then
    success "Secret added to Keychain"

    # Output the .env line
    echo ""
    echo "# Add this line to your .env file:"
    echo "${KEY_NAME}=\"keychain://${KEY_NAME}\""

    # Also provide info about verification
    echo "" >&2
    info "To verify: security find-generic-password -s \"$KEY_NAME\" -w" >&2
    info "To use: $SCRIPT_NAME use --env-file .env -- <command>" >&2
  else
    error_exit "Failed to add secret to Keychain"
  fi
}

# Function to get value from Keychain
get_keychain_value() {
  label="$1"
  if command -v security >/dev/null 2>&1; then
    # Try to get password from keychain, suppress errors
    security find-generic-password -s "$label" -w 2>/dev/null || echo ""
  else
    echo ""
  fi
}


# Process environment file and replace keychain:// references
process_env_file() {
  env_file="$1"
  temp_file=$(mktemp)

  if [ ! -f "$env_file" ]; then
    return 0
  fi

  while IFS= read -r line || [ -n "$line" ]; do
    # Skip comments and empty lines
    case "$line" in
      '#'*|'')
        echo "$line" >> "$temp_file"
        continue
        ;;
    esac

    # Check if line contains an assignment
    if echo "$line" | grep -q '='; then
      var_name="${line%%=*}"
      var_value="${line#*=}"

      # Remove quotes if present
      var_value=$(echo "$var_value" | sed 's/^["'"'"']//;s/["'"'"']$//')

      # Check for keychain:// prefix
      if echo "$var_value" | grep -q '^keychain://'; then
        label="${var_value#keychain://}"
        resolved_value=$(get_keychain_value "$label")
        if [ -n "$resolved_value" ]; then
          var_value="$resolved_value"
        fi
      fi

      # Write the processed line - quote the value if it contains special characters
      if echo "$var_value" | grep -q '[&|()<>; ]'; then
        printf '%s="%s"\n' "${var_name}" "${var_value}" >> "$temp_file"
      else
        printf '%s=%s\n' "${var_name}" "${var_value}" >> "$temp_file"
      fi
    else
      echo "$line" >> "$temp_file"
    fi
  done < "$env_file"

  echo "$temp_file"
}

# Function to use secrets from env file
use_secrets() {
  local env_file=""
  local args=()

  # Parse arguments
  while [ $# -gt 0 ]; do
    case "$1" in
      --env-file)
        if [ -z "$2" ]; then
          error_exit "--env-file requires an argument"
        fi
        env_file="$2"
        shift 2
        ;;
      --)
        shift
        break
        ;;
      *)
        args+=("$1")
        shift
        ;;
    esac
  done

  # Add remaining arguments after --
  while [ $# -gt 0 ]; do
    args+=("$1")
    shift
  done

  # Default to .env if not specified
  if [ -z "$env_file" ]; then
    env_file=".env"
  fi

  # Check if there's a command to run
  if [ ${#args[@]} -eq 0 ]; then
    error_exit "No command specified. Use: $SCRIPT_NAME use --env-file .env -- command [args...]"
  fi

  # Process the env file
  if [ -f "$env_file" ]; then
    processed_env=$(process_env_file "$env_file")

    # Export the processed environment variables
    if [ -f "$processed_env" ]; then
      set -a  # Mark all new variables for export
      . "$processed_env"
      set +a
      rm -f "$processed_env"
    fi
  else
    info "Warning: env file '$env_file' not found, proceeding without it"
  fi

  # Execute the command with the processed environment
  exec "${args[@]}"
}

# Function to remove secret from keychain
remove_secret() {
  if ! command -v security >/dev/null 2>&1; then
    error_exit "This command requires macOS with the 'security' command"
  fi

  if [ $# -lt 1 ]; then
    error_exit "KEY_NAME is required. Usage: $SCRIPT_NAME remove KEY_NAME"
  fi

  local KEY_NAME="$1"

  # Check if entry exists
  if security find-generic-password -s "$KEY_NAME" >/dev/null 2>&1; then
    # Delete the entry
    if security delete-generic-password -s "$KEY_NAME" >/dev/null 2>&1; then
      success "Secret '$KEY_NAME' removed from Keychain"
    else
      error_exit "Failed to remove secret '$KEY_NAME' from Keychain"
    fi
  else
    error_exit "Secret '$KEY_NAME' not found in Keychain"
  fi
}

# Function to show secret value
show_secret() {
  if ! command -v security >/dev/null 2>&1; then
    error_exit "This command requires macOS with the 'security' command"
  fi

  if [ $# -lt 1 ]; then
    error_exit "KEY_NAME is required. Usage: $SCRIPT_NAME show KEY_NAME"
  fi

  local KEY_NAME="$1"
  local value

  # Get the secret value
  value=$(security find-generic-password -s "$KEY_NAME" -w 2>/dev/null)

  if [ $? -eq 0 ] && [ -n "$value" ]; then
    echo "$value"
  else
    error_exit "Secret '$KEY_NAME' not found in Keychain"
  fi
}

# Function to copy secret to clipboard
copy_secret() {
  if ! command -v security >/dev/null 2>&1; then
    error_exit "This command requires macOS with the 'security' command"
  fi

  if ! command -v pbcopy >/dev/null 2>&1; then
    error_exit "This command requires macOS with the 'pbcopy' command"
  fi

  if [ $# -lt 1 ]; then
    error_exit "KEY_NAME is required. Usage: $SCRIPT_NAME copy KEY_NAME"
  fi

  local KEY_NAME="$1"
  local value

  # Get the secret value
  value=$(security find-generic-password -s "$KEY_NAME" -w 2>/dev/null)

  if [ $? -eq 0 ] && [ -n "$value" ]; then
    echo -n "$value" | pbcopy
    success "Secret '$KEY_NAME' copied to clipboard"
    info "Clipboard will be cleared in 45 seconds for security"

    # Clear clipboard after 45 seconds in background
    (
      sleep 45
      echo -n "" | pbcopy
    ) &
  else
    error_exit "Secret '$KEY_NAME' not found in Keychain"
  fi
}

# Function to list secrets matching pattern
list_secrets() {
  if ! command -v security >/dev/null 2>&1; then
    error_exit "This command requires macOS with the 'security' command"
  fi

  local pattern="${1:-*}"

  # Convert simple wildcards to grep pattern
  local grep_pattern
  if [ "$pattern" = "*" ]; then
    grep_pattern=".*"
  else
    # Convert shell pattern to regex
    grep_pattern=$(echo "$pattern" | sed 's/\*/.*/g' | sed 's/\?/./g')
    grep_pattern="^${grep_pattern}$"
  fi

  echo -e "${BLUE}Secrets in Keychain matching '$pattern':${NC}"
  echo ""

  # List secrets using security find-generic-password
  # We'll try common secret names and patterns
  local secrets=""
  local temp_list=$(mktemp)

  # Get all keychains
  local keychains=$(security list-keychains | tr -d '"' | tr '\n' ' ')

  # Use security dump-keychain with login keychain
  security dump-keychain ~/Library/Keychains/login.keychain-db 2>/dev/null | \
    grep -E '0x00000007.*<blob>=' | \
    sed 's/.*<blob>="\(.*\)"/\1/' | \
    grep -E "$grep_pattern" | \
    sort -u > "$temp_list"

  secrets=$(cat "$temp_list")
  rm -f "$temp_list"

  if [ -z "$secrets" ]; then
    echo "  No secrets found matching pattern '$pattern'"
  else
    echo "$secrets" | while IFS= read -r secret; do
      echo "  • $secret"
    done
    echo ""
    info "Use '$SCRIPT_NAME show KEY_NAME' to view a secret"
    info "Use '$SCRIPT_NAME copy KEY_NAME' to copy to clipboard"
  fi
}

# Main command dispatcher
case "${1:-}" in
  add)
    shift
    add_secret "$@"
    ;;
  remove|rm)
    shift
    remove_secret "$@"
    ;;
  show)
    shift
    show_secret "$@"
    ;;
  copy)
    shift
    copy_secret "$@"
    ;;
  ls|list)
    shift
    list_secrets "$@"
    ;;
  use)
    shift
    use_secrets "$@"
    ;;
  version|--version|-v)
    echo "kcm version $VERSION"
    ;;
  help|--help|-h)
    show_help
    ;;
  "")
    show_help
    exit 1
    ;;
  *)
    echo -e "${RED}Error: Unknown command '$1'${NC}" >&2
    echo "" >&2
    echo "Available commands: add, remove, show, copy, ls, use, version, help" >&2
    echo "Try '$SCRIPT_NAME help' for more information." >&2
    exit 1
    ;;
esac
