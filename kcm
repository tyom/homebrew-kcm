#!/usr/bin/env bash
# kcm: Keychain Master - Secret management utility for macOS Keychain
# Version: 0.3.0
#
# Usage:
#   kcm add KEY_NAME             - Add secret to Keychain
#   kcm remove KEY_NAME          - Remove secret from Keychain
#   kcm show KEY_NAME            - Display secret value
#   kcm copy KEY_NAME            - Copy secret to clipboard (auto-clears after 45s)
#   kcm ls [pattern]             - List secrets matching pattern
#   kcm use [options] -- command - Run command with secrets from .env
#   kcm help                     - Show this help message
#
# Examples:
#   kcm add API_KEY              # Interactive mode
#   echo "secret" | kcm add TOKEN -  # From stdin
#   kcm remove OLD_KEY
#   kcm show DATABASE_URL
#   kcm copy API_KEY
#   kcm ls "DATABASE*"           # List all DATABASE secrets
#   kcm use --env-file .env -- npm run dev

set -euo pipefail

VERSION="0.3.0"
SCRIPT_NAME="$(basename "$0")"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
GREY='\033[90m'
NC='\033[0m' # No Color

# Array to track clipboard clear PIDs
declare -a CLIPBOARD_CLEAR_PIDS=()
# Arrays holding processed env assignments (stay in memory)
declare -a PROCESSED_ENV_NAMES=()
declare -a PROCESSED_ENV_VALUES=()

# Global cleanup function
cleanup() {
  local exit_code=$?

  exit $exit_code
}

# Cleanup function for abnormal termination (INT/TERM signals)
cleanup_on_signal() {
  # Clear clipboard immediately to prevent secret leakage
  echo -n "" | pbcopy 2>/dev/null || true

  # Kill all clipboard clear jobs
  if [ ${#CLIPBOARD_CLEAR_PIDS[@]} -gt 0 ]; then
    for pid in "${CLIPBOARD_CLEAR_PIDS[@]}"; do
      kill "$pid" 2>/dev/null || true
    done
  fi

  exit 130  # Standard exit code for SIGINT
}

# Set up signal handlers for graceful cleanup
trap cleanup EXIT
trap cleanup_on_signal INT TERM

# Helper functions
error_exit() {
  echo -e "${RED}Error: $1${NC}" >&2
  exit 1
}

success() {
  echo -e "${GREEN}✓${NC} $1" >&2
}

info() {
  echo -e "${YELLOW}ℹ${NC} $1" >&2
}

show_help() {
  cat << EOF
kcm - Keychain Master

USAGE:
  $SCRIPT_NAME <command> [options]

COMMANDS:
  add KEY_NAME
    Add a secret to Keychain and output the .env entry

    Options:
      KEY_NAME          - Interactive mode (prompts for value)
      KEY_NAME -        - Read value from stdin

    Examples:
      kcm add API_KEY      # Prompts for value
      echo "secret" | kcm add TOKEN -
      cat ~/secret.txt | kcm add AWS_KEY -

  remove KEY_NAME
    Remove a secret from Keychain

    Example:
      kcm remove OLD_API_KEY

  show KEY_NAME
    Display the value of a secret from Keychain

    Example:
      kcm show DATABASE_URL

  copy KEY_NAME
    Copy a secret value to clipboard (auto-clears after 45 seconds)

    Example:
      kcm copy API_KEY

  ls [pattern]
    List accessible secrets in Keychain matching pattern (supports wildcards)

    Note: Only shows secrets that kcm can access. Some application-specific
    secrets may exist in your keychain but have special access controls
    that prevent kcm from reading them.

    Examples:
      kcm ls               # List all accessible secrets
      kcm ls 'DATABASE*'   # List secrets starting with DATABASE
      kcm ls '*_KEY'       # List secrets ending with _KEY

  use [options] -- command [args...]
    Run a command with secrets from .env file resolved

    Options:
      --env-file FILE   - Specify the .env file to use (default: .env)
      --allow-unsafe    - Allow special characters in env values that are normally blocked
                          for security (use with caution, only with trusted sources)

    Examples:
      kcm use --env-file .env -- npm run dev
      kcm use --env-file ../.env -- make run-server
      kcm use --env-file .env -- echo \$DATABASE_URL
      kcm use --allow-unsafe --env-file secrets.env -- docker run myapp

  help
    Show this help message

ENVIRONMENT VARIABLE FORMAT:
  keychain://LABEL - Retrieved from macOS Keychain

  If a secret cannot be resolved, the original value is used as fallback.

EOF
}

# Function to add secret to keychain
add_secret() {
  # Check if running on macOS
  if ! command -v security >/dev/null 2>&1; then
    error_exit "This command requires macOS with the 'security' command"
  fi

  if [ $# -lt 1 ]; then
    echo -e "${RED}Error: KEY_NAME is required${NC}" >&2
    echo "" >&2
    echo "Usage: $SCRIPT_NAME add KEY_NAME" >&2
    echo "" >&2
    echo "Examples:" >&2
    echo "  $SCRIPT_NAME add API_KEY                    # Interactive" >&2
    echo "  echo \"secret\" | $SCRIPT_NAME add TOKEN -   # From stdin" >&2
    exit 1
  fi

  local KEY_NAME="$1"
  local SECRET_VALUE=""

  # Validate key name (alphanumeric and underscore only)
  if ! [[ "$KEY_NAME" =~ ^[A-Za-z][A-Za-z0-9_]*$ ]]; then
    error_exit "Key name must start with a letter and contain only letters, numbers, and underscores"
  fi

  # Get the secret value
  if [ $# -eq 1 ]; then
    # Interactive mode - prompt for value
    info "Enter secret value for $KEY_NAME (input will be hidden):"
    echo -e "${GREY}For long secrets (>1000 chars), use: ${GREEN}pbpaste | $SCRIPT_NAME add $KEY_NAME -${NC}" >&2
    read -rs SECRET_VALUE
    echo "" >&2  # New line after hidden input

    if [ -z "$SECRET_VALUE" ]; then
      error_exit "Secret value cannot be empty"
    fi
  elif [ "$2" = "-" ]; then
    # Read from stdin
    SECRET_VALUE=$(cat)

    if [ -z "$SECRET_VALUE" ]; then
      error_exit "No input received from stdin"
    fi
  else
    error_exit "Inline values are not supported. Use interactive input or pipe via '-'"
  fi

  # Check if entry already exists
  if keychain_entry_exists "$KEY_NAME"; then
    info "Keychain entry '$KEY_NAME' already exists. Updating..."
    # Delete existing entry (suppress all output)
    security delete-generic-password -s "$KEY_NAME" >/dev/null 2>&1
  fi

  # Add to keychain (suppress verbose output)
  if security add-generic-password -s "$KEY_NAME" -a "$USER" -w "$SECRET_VALUE" -U >/dev/null 2>&1; then
    success "Secret added to Keychain"

    # Output the .env line
    echo ""
    echo "# Add this line to your .env file:"
    echo "${KEY_NAME}=\"keychain://${KEY_NAME}\""

    # Also provide info about verification
    echo "" >&2
    info "To verify: security find-generic-password -s \"$KEY_NAME\" -w" >&2
    info "To use: $SCRIPT_NAME use --env-file .env -- <command>" >&2
  else
    error_exit "Failed to add secret to Keychain"
  fi
}

# Function to get value from Keychain
get_keychain_value() {
  local label="$1"
  if command -v security >/dev/null 2>&1; then
    # Try to get password from keychain, suppress errors
    security find-generic-password -s "$label" -w 2>/dev/null || echo ""
  else
    echo ""
  fi
}

# Check if a keychain entry exists
keychain_entry_exists() {
  local key_name="$1"
  security find-generic-password -s "$key_name" >/dev/null 2>&1
}

# Remove outer quotes from a string (double or single)
remove_outer_quotes() {
  local value="$1"
  if [[ "$value" =~ ^\".*\"$ ]]; then
    value="${value#\"}"
    value="${value%\"}"
  elif [[ "$value" =~ ^\'.*\'$ ]]; then
    value="${value#\'}"
    value="${value%\'}"
  fi
  echo "$value"
}


# Process environment file and replace keychain:// references
# This function safely parses .env files without using source/eval to prevent command injection
process_env_file() {
  local env_file="$1"
  local allow_unsafe="${2:-false}"

  # Reset processed environment arrays for this invocation
  PROCESSED_ENV_NAMES=()
  PROCESSED_ENV_VALUES=()

  if [ ! -f "$env_file" ]; then
    return 0
  fi

  while IFS= read -r line || [ -n "$line" ]; do
    # Skip comments and empty lines
    case "$line" in
      '#'*)
        continue
        ;;
      '')
        continue
        ;;
    esac

    # Check if line contains an assignment
    if [[ "$line" == *"="* ]]; then
      local var_name="${line%%=*}"
      local var_value="${line#*=}"

      # Validate variable name (must be valid shell identifier)
      if ! [[ "$var_name" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
        continue
      fi

      # Remove quotes if present (safely)
      var_value=$(remove_outer_quotes "$var_value")

      # Check for keychain:// prefix
      if [[ "$var_value" == keychain://* ]]; then
        local label="${var_value#keychain://}"
        local resolved_value
        resolved_value=$(get_keychain_value "$label")
        if [ -n "$resolved_value" ]; then
          var_value="$resolved_value"
        fi
      fi

      # Check for potentially dangerous characters unless --allow-unsafe is used
      if [ "$allow_unsafe" = "false" ]; then
        # Block command substitution and other dangerous patterns
        # Using grep for complex pattern matching (more reliable for special chars)
        if [[ "$var_value" =~ [\$\`\\\;\|\&] ]] || [[ "$var_value" =~ \$\( ]]; then
          info "Warning: Variable '$var_name' contains potentially dangerous characters, skipping" >&2
          info "         Use --allow-unsafe flag if you trust the source and need these characters" >&2
          continue
        fi
      fi

      # Skip values containing newlines to avoid malformed exports
      case "$var_value" in
        *$'\n'*)
          info "Warning: Variable '$var_name' contains newline characters, skipping" >&2
          continue
          ;;
      esac

      PROCESSED_ENV_NAMES+=("$var_name")
      PROCESSED_ENV_VALUES+=("$var_value")
    fi
  done < "$env_file"
}

# Function to use secrets from env file
use_secrets() {
  local env_file=""
  local allow_unsafe=false
  local args=()

  # Parse arguments
  while [ $# -gt 0 ]; do
    case "$1" in
      --env-file)
        if [ -z "$2" ]; then
          error_exit "--env-file requires an argument"
        fi
        env_file="$2"
        shift 2
        ;;
      --allow-unsafe)
        allow_unsafe=true
        shift
        ;;
      --)
        shift
        break
        ;;
      *)
        args+=("$1")
        shift
        ;;
    esac
  done

  # Add remaining arguments after --
  while [ $# -gt 0 ]; do
    args+=("$1")
    shift
  done

  # Default to .env if not specified
  if [ -z "$env_file" ]; then
    env_file=".env"
  fi

  # Basic security validation for env-file path
  # Only block access to known sensitive system directories
  if [[ "$env_file" =~ ^/etc/passwd ]] || [[ "$env_file" =~ ^/etc/shadow ]] || \
     [[ "$env_file" =~ ^/proc/ ]] || [[ "$env_file" =~ ^/sys/ ]] || \
     [[ "$env_file" =~ ^/dev/ ]]; then
    error_exit "Security error: Cannot use system files as env-file"
  fi

  # Optional verbose warning for paths outside current directory (can be disabled)
  if [ "${KCM_VERBOSE:-}" = "1" ]; then
    if [[ "$env_file" =~ ^\.\. ]] || [[ "$env_file" =~ ^/ ]]; then
      info "Note: Using env-file outside current directory: $env_file" >&2
    fi
  fi

  # Check if there's a command to run
  if [ ${#args[@]} -eq 0 ]; then
    error_exit "No command specified. Use: $SCRIPT_NAME use --env-file .env -- command [args...]"
  fi

  # Process the env file
  if [ -f "$env_file" ]; then
    process_env_file "$env_file" "$allow_unsafe"

    if [ ${#PROCESSED_ENV_NAMES[@]} -gt 0 ]; then
      local idx
      for idx in "${!PROCESSED_ENV_NAMES[@]}"; do
        local var_name="${PROCESSED_ENV_NAMES[$idx]}"
        local var_value="${PROCESSED_ENV_VALUES[$idx]}"
        export "$var_name=$var_value"
      done
    fi
  else
    info "Warning: env file '$env_file' not found, proceeding without it"
  fi

  # Execute the command with the processed environment
  exec "${args[@]}"
}

# Function to remove secret from keychain
remove_secret() {
  if ! command -v security >/dev/null 2>&1; then
    error_exit "This command requires macOS with the 'security' command"
  fi

  if [ $# -lt 1 ]; then
    error_exit "KEY_NAME is required. Usage: $SCRIPT_NAME remove KEY_NAME"
  fi

  local KEY_NAME="$1"

  # Check if entry exists
  if keychain_entry_exists "$KEY_NAME"; then
    # Delete the entry
    if security delete-generic-password -s "$KEY_NAME" >/dev/null 2>&1; then
      success "Secret '$KEY_NAME' removed from Keychain"
    else
      error_exit "Failed to remove secret '$KEY_NAME' from Keychain"
    fi
  else
    error_exit "Secret '$KEY_NAME' not found in Keychain"
  fi
}

# Function to show secret value
show_secret() {
  if ! command -v security >/dev/null 2>&1; then
    error_exit "This command requires macOS with the 'security' command"
  fi

  if [ $# -lt 1 ]; then
    error_exit "KEY_NAME is required. Usage: $SCRIPT_NAME show KEY_NAME"
  fi

  local KEY_NAME="$1"
  local value

  # Get the secret value
  if value=$(security find-generic-password -s "$KEY_NAME" -w 2>/dev/null) && [ -n "$value" ]; then
    echo "$value"
  else
    error_exit "Secret '$KEY_NAME' not found in Keychain"
  fi
}

# Function to copy secret to clipboard
copy_secret() {
  if ! command -v security >/dev/null 2>&1; then
    error_exit "This command requires macOS with the 'security' command"
  fi

  if ! command -v pbcopy >/dev/null 2>&1; then
    error_exit "This command requires macOS with the 'pbcopy' command"
  fi

  if [ $# -lt 1 ]; then
    error_exit "KEY_NAME is required. Usage: $SCRIPT_NAME copy KEY_NAME"
  fi

  local KEY_NAME="$1"
  local value

  # Get the secret value
  if value=$(security find-generic-password -s "$KEY_NAME" -w 2>/dev/null) && [ -n "$value" ]; then
    echo -n "$value" | pbcopy
    success "Secret '$KEY_NAME' copied to clipboard"
    info "Clipboard will be cleared in 45 seconds for security"

    # Clear clipboard after 45 seconds in background
    # Close file descriptors to avoid blocking parent terminal
    # Don't disown so we can kill it on interrupt
    (
      sleep 45
      echo -n "" | pbcopy
    ) </dev/null >/dev/null 2>&1 &
    CLIPBOARD_CLEAR_PIDS+=("$!")
  else
    error_exit "Secret '$KEY_NAME' not found in Keychain"
  fi
}

# Function to list secrets matching pattern
# NOTE: This function lists only secrets that kcm can actually access.
# Some keychain entries may be visible in the system keychain dump but have
# access restrictions that prevent them from being read by the security command.
# We test each entry for accessibility before showing it to the user.
list_secrets() {
  if ! command -v security >/dev/null 2>&1; then
    error_exit "This command requires macOS with the 'security' command"
  fi

  local pattern="${1:-*}"

  # Convert simple wildcards to regex pattern
  local grep_pattern
  if [ "$pattern" = "*" ]; then
    grep_pattern=".*"
  else
    grep_pattern=$(echo "$pattern" | sed 's/\*/.*/g' | sed 's/\?/./g')
    grep_pattern="^${grep_pattern}$"
  fi

  echo -e "${BLUE}Accessible secrets in Keychain matching '$pattern':${NC}"
  echo ""

  local -a candidates=()
  local keychains=""
  if ! keychains=$(security list-keychains 2>/dev/null | tr -d '"' | sed '/^$/d'); then
    keychains=""
  fi

  while IFS= read -r keychain; do
    [ -n "$keychain" ] || continue
    keychain=$(echo "$keychain" | xargs)

    while IFS= read -r service; do
      [ -n "$service" ] || continue
      candidates+=("$service")
    done < <(
      security dump-keychain "$keychain" 2>/dev/null | awk -v regex="$grep_pattern" '
        BEGIN { genp=0; service="" }
        /^keychain:/ { genp=0; service=""; next }
        /class: "genp"/ { genp=1; next }
        /class:/ { genp=0; service=""; next }
        /0x00000007.*<blob>="[^"]+"/ {
          if (genp) {
            service=$0
            sub(/.*<blob>="/, "", service)
            sub(/".*/, "", service)
          }
          next
        }
        /"acct"<blob>=/ {
          if (genp && service) {
            if (service ~ regex) {
              print service
            }
            service=""
          }
          next
        }
      ' || true
    )
  done <<< "$keychains"

  local -a accessible=()
  if [ ${#candidates[@]} -gt 0 ]; then
    while IFS= read -r secret; do
      [ -n "$secret" ] || continue
      if keychain_entry_exists "$secret"; then
        accessible+=("$secret")
      fi
    done < <(printf '%s\n' "${candidates[@]}" | LC_ALL=C sort -u)
  fi

  if [ ${#accessible[@]} -eq 0 ]; then
    echo "  No secrets found matching pattern '$pattern'"
  else
    local secret
    for secret in "${accessible[@]}"; do
      echo "  • $secret"
    done
    echo ""
    info "Use '$SCRIPT_NAME show KEY_NAME' to view a secret"
    info "Use '$SCRIPT_NAME copy KEY_NAME' to copy to clipboard"
  fi
}

# Main command dispatcher
case "${1:-}" in
  add)
    shift
    add_secret "$@"
    ;;
  remove|rm)
    shift
    remove_secret "$@"
    ;;
  show)
    shift
    show_secret "$@"
    ;;
  copy)
    shift
    copy_secret "$@"
    ;;
  ls|list)
    shift
    list_secrets "$@"
    ;;
  use)
    shift
    use_secrets "$@"
    ;;
  version|--version|-v)
    echo "kcm version $VERSION"
    ;;
  help|--help|-h)
    show_help
    ;;
  "")
    show_help
    exit 1
    ;;
  *)
    echo -e "${RED}Error: Unknown command '$1'${NC}" >&2
    echo "" >&2
    echo "Available commands: add, remove, show, copy, ls, use, version, help" >&2
    echo "Try '$SCRIPT_NAME help' for more information." >&2
    exit 1
    ;;
esac
